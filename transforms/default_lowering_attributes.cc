// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "transforms/default_lowering_attributes.h"

#include <memory>

#include "llvm/ADT/ArrayRef.h"
#include "llvm/ADT/BitVector.h"
#include "llvm/ADT/SmallVector.h"
#include "mlir/IR/Attributes.h"
#include "mlir/IR/BuiltinOps.h"
#include "mlir/IR/MLIRContext.h"
#include "mlir/Pass/Pass.h"
#include "mlir/Pass/PassManager.h"
#include "sair_attributes.h"
#include "sair_op_interfaces.h"
#include "sair_ops.h"
#include "storage.h"

namespace sair {
namespace {

// Include passes base class declaration generated by MLIR. This file should not
// be included anywhere else with GEN_PASS_CLASSES set. The #define in front
// selects the part of the file to include (pass base class declaration or pass
// registration). See
// https://mlir.llvm.org/docs/PassManagement/#declarative-pass-specification for
// more information.
#define GEN_PASS_CLASSES
#include "transforms/default_lowering_attributes.h.inc"

// Assigns the default storage to sair values. This uses registers when possible
// and materializes the minimum amount of dimensions in RAM otherwise. Fails if
// the sub-domain of dimensions to materialize is a dependend domain.
class DefaultStorage : public DefaultStoragePassBase<DefaultStorage> {
 public:
  void runOnFunction() override {
    mlir::MLIRContext *context = &getContext();
    auto *sair_dialect = context->getLoadedDialect<SairDialect>();

    auto result = getFunction().walk([&](ComputeOp op) -> mlir::WalkResult {
      auto sair_op = cast<SairOp>(op.getOperation());
      auto &storage_analysis =
          getChildAnalysis<StorageAnalysis>(op->getParentOp());

      for (int i = 0, e = op->getNumResults(); i < e; ++i) {
        if (op.Storage(i) != nullptr) continue;
        if (!op.loop_nest().hasValue()) {
          return op.emitError() << "expected a loop-nest attribute";
        }

        BufferAttr buffer;
        if (sair_op.shape().Is0d()) {
          buffer = BufferAttr::get(
              /*space=*/sair_dialect->register_attr(),
              /*name=*/nullptr,
              /*layout=*/NamedMappingAttr::GetIdentity(context, {}), context);
        } else {
          auto type = op->getResultTypes()[i].cast<ValueType>();
          if (type.ElementType().isa<mlir::IndexType>()) {
            return op.emitError() << "cannot generate default storage for "
                                     "multi-dimensional index values";
          }
          if (!sair_op.shape().IsHyperRectangular()) {
            return op.emitError() << "cannot generate default storage for "
                                     "non-rectangular shapes";
          }

          llvm::SmallVector<mlir::StringAttr> loop_names;
          llvm::SmallVector<MappingExpr> loop_iters;
          for (auto attr : op.LoopNestLoops()) {
            LoopAttr loop = attr.cast<LoopAttr>();
            loop_names.push_back(loop.name());
            loop_iters.push_back(loop.iter());
          }

          // Keep the original operation shape for the storage shape.
          auto loops_mapping =
              MappingAttr::get(context, sair_op.domain().size(), loop_iters);
          auto layout =
              NamedMappingAttr::get(loop_names, loops_mapping.Inverse());

          buffer = BufferAttr::get(
              /*space=*/sair_dialect->memory_attr(),
              /*name=*/storage_analysis.GetFreshBufferName(),
              /*layout=*/layout, context);
        }
        op.SetStorage(i, buffer);
      }
      return mlir::success();
    });

    if (result.wasInterrupted()) {
      signalPassFailure();
    }
  }
};

// Sets the `loop_nest` attribute to its default value. The default loop nest
// iterates over each dimension of the domain, in order, without
// rematerialization or strip-mining.
class DefaultLoopNest : public DefaultLoopNestPassBase<DefaultLoopNest> {
 public:
  void runOnFunction() override {
    getFunction().walk([](ComputeOp op) {
      if (op.loop_nest().hasValue()) return;
      SairOp sair_op = cast<SairOp>(op.getOperation());
      SairProgramOp program_op = cast<SairProgramOp>(op->getParentOp());
      int num_dimensions = sair_op.shape().NumDimensions();
      op.setLoopNest(GetDefaultLoopNest(program_op, num_dimensions));
    });
  }
};

}  // namespace

mlir::ArrayAttr GetDefaultLoopNest(SairProgramOp program, int num_dimensions,
                                   llvm::ArrayRef<mlir::Attribute> prefix) {
  mlir::MLIRContext *context = program.getContext();
  llvm::SmallVector<MappingExpr, 4> iter_exprs;
  for (mlir::Attribute attr : prefix) {
    LoopAttr loop = attr.cast<LoopAttr>();
    iter_exprs.push_back(loop.iter());
  }

  // Inverse iter expressions and complete the resulting mapping by
  // allocating new loops. Then inverse again to obtain loop iterators.
  MappingAttr partial_inverse =
      MappingAttr::get(context, num_dimensions, iter_exprs).Inverse();
  MappingAttr full_inverse = partial_inverse.MakeFullySpecified();
  MappingAttr new_iter_exprs = full_inverse.Inverse();

  llvm::SmallVector<mlir::Attribute, 8> loop_nest(prefix.begin(), prefix.end());
  for (MappingExpr expr :
       new_iter_exprs.Dimensions().drop_front(prefix.size())) {
    mlir::StringAttr name = program.GenLoopName("loop");
    loop_nest.push_back(LoopAttr::get(name, expr, context));
  }

  return mlir::ArrayAttr::get(context, loop_nest);
}

std::unique_ptr<mlir::Pass> CreateDefaultStoragePass() {
  return std::make_unique<DefaultStorage>();
}

std::unique_ptr<mlir::Pass> CreateDefaultLoopNestPass() {
  return std::make_unique<DefaultLoopNest>();
}

void CreateDefaultLoweringAttributesPipeline(mlir::OpPassManager *pm) {
  pm->addPass(CreateDefaultLoopNestPass());
  pm->addPass(CreateDefaultStoragePass());
}

}  // namespace sair
