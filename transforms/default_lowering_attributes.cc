// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "transforms/default_lowering_attributes.h"

#include <memory>

#include "llvm/ADT/ArrayRef.h"
#include "llvm/ADT/BitVector.h"
#include "llvm/ADT/SmallVector.h"
#include "mlir/IR/Attributes.h"
#include "mlir/IR/BuiltinOps.h"
#include "mlir/IR/MLIRContext.h"
#include "mlir/Pass/Pass.h"
#include "mlir/Pass/PassManager.h"
#include "sair_attributes.h"
#include "sair_op_interfaces.h"
#include "sair_ops.h"
#include "storage.h"

namespace sair {
namespace {

// Include passes base class declaration generated by MLIR. This file should not
// be included anywhere else with GEN_PASS_CLASSES set. The #define in front
// selects the part of the file to include (pass base class declaration or pass
// registration). See
// https://mlir.llvm.org/docs/PassManagement/#declarative-pass-specification for
// more information.
#define GEN_PASS_CLASSES
#include "transforms/default_lowering_attributes.h.inc"

// Writes the storage information infered by the storage analysis pass to
// Compute operations.
mlir::LogicalResult CommitStorage(
    ComputeOp op, const IterationSpaceAnalysis &iteration_spaces,
    const StorageAnalysis &storage_analysis) {
  mlir::MLIRContext *context = op.getContext();
  const IterationSpace &iter_space = iteration_spaces.Get(op.getOperation());

  for (int i = 0, e = op->getNumResults(); i < e; ++i) {
    const ValueStorage &storage = storage_analysis.GetStorage(op->getResult(i));
    if (storage.space() == nullptr) continue;
    llvm::SmallBitVector indexed_loops = storage.layout().DependencyMask();
    if (indexed_loops.find_last() >=
        static_cast<int>(iter_space.loop_names().size())) {
      return op.emitError() << "incomplete loop nest";
    }

    auto none = MappingNoneExpr::get(context);
    llvm::SmallVector<MappingExpr> renaming(iter_space.mapping().size(), none);
    llvm::SmallVector<mlir::StringAttr> loop_names;
    for (int loop : indexed_loops.set_bits()) {
      renaming[loop] = MappingDimExpr::get(loop_names.size(), context);
      loop_names.push_back(iter_space.loop_names()[loop]);
    }

    auto layout = NamedMappingAttr::get(loop_names, renaming, context)
                      .Compose(storage.layout());
    auto attr = BufferAttr::get(storage.space(), storage.buffer_name(), layout,
                                context);
    op.SetStorage(i, attr);
  }
  return mlir::success();
}

// Creates and sets a buffer attribute for result `result` of `op`.
mlir::LogicalResult GenerateBufferAttr(ComputeOp op, int result,
                                       StorageAnalysis &storage_analysis) {
  mlir::MLIRContext *context = op->getContext();
  auto *sair_dialect = context->getLoadedDialect<SairDialect>();
  auto sair_op = cast<SairOp>(op.getOperation());

  BufferAttr buffer;
  if (sair_op.shape().Is0d()) {
    buffer = BufferAttr::get(
        /*space=*/sair_dialect->register_attr(),
        /*name=*/nullptr,
        /*layout=*/NamedMappingAttr::GetIdentity(context, {}), context);
  } else {
    auto type = op->getResultTypes()[result].cast<ValueType>();
    if (type.ElementType().isa<mlir::IndexType>()) {
      return op.emitError() << "cannot generate default storage for "
                               "multi-dimensional index values";
    }
    if (!sair_op.shape().IsHyperRectangular()) {
      return op.emitError() << "cannot generate default storage for "
                               "non-rectangular shapes";
    }

    llvm::SmallVector<mlir::StringAttr> loop_names;
    llvm::SmallVector<MappingExpr> loop_iters;
    for (auto attr : op.LoopNestLoops()) {
      LoopAttr loop = attr.cast<LoopAttr>();
      loop_names.push_back(loop.name());
      loop_iters.push_back(loop.iter());
    }

    // Keep the original operation shape for the storage shape.
    auto loops_mapping =
        MappingAttr::get(context, sair_op.domain().size(), loop_iters);
    auto layout = NamedMappingAttr::get(loop_names, loops_mapping.Inverse());

    buffer = BufferAttr::get(
        /*space=*/sair_dialect->memory_attr(),
        /*name=*/storage_analysis.GetFreshBufferName(),
        /*layout=*/layout, context);
  }
  op.SetStorage(result, buffer);
  return mlir::success();
}

// Assigns the default storage to sair values. This uses registers when possible
// and materializes the minimum amount of dimensions in RAM otherwise. Fails if
// the sub-domain of dimensions to materialize is a dependent domain.
class DefaultStorage : public DefaultStoragePassBase<DefaultStorage> {
 public:
  void runOnFunction() override {
    auto result = getFunction().walk([&](ComputeOp op) -> mlir::WalkResult {
      auto &iteration_spaces =
          getChildAnalysis<IterationSpaceAnalysis>(op->getParentOp());
      auto &storage_analysis =
          getChildAnalysis<StorageAnalysis>(op->getParentOp());
      if (mlir::failed(CommitStorage(op, iteration_spaces, storage_analysis))) {
        return mlir::failure();
      }

      for (int i = 0, e = op->getNumResults(); i < e; ++i) {
        if (op.Storage(i) != nullptr) continue;
        if (!op.loop_nest().hasValue()) {
          return op.emitError() << "expected a loop-nest attribute";
        }
        if (mlir::failed(GenerateBufferAttr(op, i, storage_analysis))) {
          return mlir::failure();
        }
      }
      return mlir::success();
    });

    if (result.wasInterrupted()) {
      signalPassFailure();
    }
  }
};

// Generates the default `loop_nest` attribute for an operation with the given
// number of dimensions. The loop nest will start with the given prefix.
mlir::ArrayAttr GetDefaultLoopNest(int num_dimensions,
                                   llvm::ArrayRef<mlir::Attribute> prefix,
                                   LoopFusionAnalysis &fusion_analysis) {
  mlir::MLIRContext *context = fusion_analysis.getContext();
  llvm::SmallVector<MappingExpr, 4> iter_exprs;
  for (mlir::Attribute attr : prefix) {
    LoopAttr loop = attr.cast<LoopAttr>();
    iter_exprs.push_back(loop.iter());
  }

  // Inverse iter expressions and complete the resulting mapping by
  // allocating new loops. Then inverse again to obtain loop iterators.
  MappingAttr partial_inverse =
      MappingAttr::get(context, num_dimensions, iter_exprs).Inverse();
  MappingAttr full_inverse = partial_inverse.MakeSurjective();
  MappingAttr new_iter_exprs = full_inverse.Inverse();

  llvm::SmallVector<mlir::Attribute, 8> loop_nest(prefix.begin(), prefix.end());
  for (MappingExpr expr :
       new_iter_exprs.Dimensions().drop_front(prefix.size())) {
    mlir::StringAttr name = fusion_analysis.GetFreshLoopName();
    loop_nest.push_back(LoopAttr::get(name, expr, context));
  }

  return mlir::ArrayAttr::get(context, loop_nest);
}

// Sets the `loop_nest` attribute to its default value. The default loop nest
// iterates over each dimension of the domain, in order, without
// rematerialization or strip-mining.
class DefaultLoopNest : public DefaultLoopNestPassBase<DefaultLoopNest> {
 public:
  void runOnFunction() override {
    getFunction().walk([&](ComputeOp op) {
      if (op.loop_nest().hasValue()) return;
      SairOp sair_op = cast<SairOp>(op.getOperation());
      SairProgramOp program_op = cast<SairProgramOp>(op->getParentOp());
      auto &fusion_analysis = getChildAnalysis<LoopFusionAnalysis>(program_op);
      int num_dimensions = sair_op.shape().NumDimensions();
      op.setLoopNest(GetDefaultLoopNest(num_dimensions, {}, fusion_analysis));
    });
  }
};

}  // namespace

std::unique_ptr<mlir::Pass> CreateDefaultStoragePass() {
  return std::make_unique<DefaultStorage>();
}

std::unique_ptr<mlir::Pass> CreateDefaultLoopNestPass() {
  return std::make_unique<DefaultLoopNest>();
}

void CreateDefaultLoweringAttributesPipeline(mlir::OpPassManager *pm) {
  pm->addPass(CreateDefaultLoopNestPass());
  pm->addPass(CreateDefaultStoragePass());
}

}  // namespace sair
